module sal

     use precisions, only: wp, cwp
     use my_trigs
     use save_load
     use spherepack_iface

!     integer, parameter :: LongIntType = selected_int_kind(10)
!
     type tide_params

          real(wp) :: amp,lovef,omega0

     end type

contains

!**********************************************************************************************************
!**********************************************************************************************************

subroutine calc_hsal_col(h_col, nph, nth,  P, GD, dir_cols, dir_grid)

!% [hsal_col,beta0,beta_col]=calc_hsal_col_merc(h_col,flags)
!% Given a column vector of surface heights h_col, distributed
!% globally according to information in , calculates the
!% corresponding h_SAL in column format, along with a local
!% beta term (h_SAL approx = beta.*h), and a global average beta0.

implicit none

     integer, allocatable   :: hp(:,:)
     integer, intent(in)    :: nph, nth, nh
     type(params)	:: P
     type(grid_dims):: GD

     type (triplet)	      :: triplet_h
     complex(cwp),allocatable :: h(:,:)

     character(len=2)     :: cpt
     real(wp)             :: th0, ph0

     real(wp), pointer    :: th_h(:), ph_h(:)
     integer            :: j, istat

     character(len = *) :: dir_grid, dir_cols

     complex(cwp), allocatable, dimension(:) :: heq

! shortcuts
nph = GD%nph
nth = GD%nta
! load hp and project hcol to the grid
     call load_alloc_mat_int(hp, dir_cols // 'hp.dat')

    call init_sparse(triplet_tmp, hp(:,1),hp(:,2),h_col, nph,nth, nh)
    call coo2ful(triplet_h, h)
    call dealloc_sparse(triplet_h)

!%===============
!% calculate heq
!%===============
!    if (associated(th_h)) deallocate(th_h)
!    allocate(th_h(nh), stat = status1)
!    if (associated(ph_h)) deallocate(ph_h)
!    allocate(ph_h(nh), stat = status2)
!
!    allocate(heq(nh), stat = status3)
!
!th_h = (/ ( (ta2th(ta_h(j))), j=1,nh ) /)
!ph_h = ph_vg(hp(:,1)) ! 1 for ph coordinate
!
!     deallocate(ta_h, ph_vg, hp)
!
!th0 = DegreeToRadian(latP)
!ph0 = DegreeToRadian(lonP)

 call calc_hsal_gridded(h, hsal, beta0, beta, dir_grid)

!call save_vector(ta_ug, '/home/amsta/amtvl/Desktop/scratch/Tides/data/cols_ta.dat')
!call save_vector(ph_vg, '/home/amsta/amtvl/Desktop/scratch/Tides/data/cols_ph.dat')
!call save_matrix(h_abs, '/home/amsta/amtvl/Desktop/scratch/Tides/data/mats_h_abs.dat')

end subroutine calc_hsal_col

!**********************************************************************************************************
!**********************************************************************************************************

subroutine calc_hsal_gridded(h, hsal, beta0, beta, P, GD)

!% Given h on a (phi,tau) grid, calculates hsal and beta
!% on the corresponding grid. Also calculates a single
!% globally integrated value beta0.

implicit none

     integer, allocatable   :: hp(:,:)
     integer, intent(in)    :: nph, nth, nh
     type(params)	:: P
     type(grid_dims):: GD
     type (triplet)			:: triplet_h
     complex(cwp),allocatable	:: h(:,:)

     character(len=2)     :: cpt
     real(wp)             :: th0, ph0

     real(wp), pointer    :: th_h(:), ph_h(:)
     integer            :: j, istat

     character(len = *) :: dir_grid, dir_cols

     complex(cwp), allocatable, dimension(:) :: heq

! shortcuts
nph = GD%nph
nth = GD%nta
! load th_ug, ph_vg, ta_h
     call load_alloc_vector(ph_vg, dir_grid // 'ph_vg.dat')
!     call load_alloc_vector(ta_ug, dir_grid // 'ta_ug.dat')
     call load_alloc_vector(ta_h, dir_cols // 'ta_h.dat')

!%===============
!% calculate heq
!%===============
!    if (associated(th_h)) deallocate(th_h)
!    allocate(th_h(nh), stat = status1)
!    if (associated(ph_h)) deallocate(ph_h)
!    allocate(ph_h(nh), stat = status2)
!
!    allocate(heq(nh), stat = status3)
!
!th_h = (/ ( (ta2th(ta_h(j))), j=1,nh ) /)
!ph_h = ph_vg(hp(:,1)) ! 1 for ph coordinate
!
!     deallocate(ta_h, ph_vg, hp)
!
!th0 = DegreeToRadian(latP)
!ph0 = DegreeToRadian(lonP)

 call calc_hsal_gridded(h, hsal, beta0, beta)

!call save_vector(ta_ug, '/home/amsta/amtvl/Desktop/scratch/Tides/data/cols_ta.dat')
!call save_vector(ph_vg, '/home/amsta/amtvl/Desktop/scratch/Tides/data/cols_ph.dat')
!call save_matrix(h_abs, '/home/amsta/amtvl/Desktop/scratch/Tides/data/mats_h_abs.dat')

end subroutine calc_hsal_col

!**********************************************************************************************************
!**********************************************************************************************************

subroutine calc_heq_h(heq, cpt, nh, latP, lonP, dir_cols, dir_grid)

!% calculates the (complex) equilibrium tide heq
!% on the h grid, for the specified domain
implicit none

     real(wp), allocatable        :: ta_h(:), ph_vg(:)!, ta_ug(:)
     integer, allocatable       :: hp(:,:)

     real(wp), intent(in)     :: latP, lonP
     integer, intent(in)    :: nh

     character(len=2)   :: cpt
     real(wp)             :: th0, ph0

     real(wp), pointer    :: th_h(:), ph_h(:)
     integer            :: j, status1, status2, status3

     character(len = *) :: dir_grid, dir_cols

     complex(cwp), allocatable, dimension(:) :: heq

! load hp, ph_vg, ta_h
     call load_alloc_mat_int(hp, dir_cols // 'hp.dat')
     call load_alloc_vector(ph_vg, dir_grid // 'ph_vg.dat')
!     call load_alloc_vector(ta_ug, dir_grid // 'ta_ug.dat')
     call load_alloc_vector(ta_h, dir_cols // 'ta_h.dat')

!%===============
!% calculate heq
!%===============
    if (associated(th_h)) deallocate(th_h)
    allocate(th_h(nh), stat = status1)
    if (associated(ph_h)) deallocate(ph_h)
    allocate(ph_h(nh), stat = status2)

    allocate(heq(nh), stat = status3)

th_h = (/ ( (ta2th(ta_h(j))), j=1,nh ) /)
!th_h = (/ ( (ta2th(ta_ug(hp(j,2)))), j=1,nh ) /)
ph_h = ph_vg(hp(:,1)) ! 1 for ph coordinate

     deallocate(ta_h, ph_vg, hp)

th0 = DegreeToRadian(latP)
ph0 = DegreeToRadian(lonP)

 call calc_heq_i(heq, cpt, th_h, ph_h, th0,ph0)

!allocate(h_abs(size(ph_vg),size(ta_ug)), stat = status3)
!h_abs = 0
!
!do j = 1,size(th_h)
!    h_abs(hp(j,1), hp(j,2)) = abs(heq(j))
!enddo

!call save_vector(ta_ug, '/home/amsta/amtvl/Desktop/scratch/Tides/data/cols_ta.dat')
!call save_vector(ph_vg, '/home/amsta/amtvl/Desktop/scratch/Tides/data/cols_ph.dat')
!call save_matrix(h_abs, '/home/amsta/amtvl/Desktop/scratch/Tides/data/mats_h_abs.dat')

end subroutine calc_heq_h

!**********************************************************************************************************
!**********************************************************************************************************

subroutine calc_heq_i(heq, cpt,th,ph,th0,ph0)
!
!% returns a complex equilibrium tide heq, where the actual
!% equilibrium tide is Re ( heq(th,ph) e(-i w t) ).
!% if th and ph are the same size, returns heq at that size.
!% if th is column and ph is row, returns heq as th x ph matrices.
!% th0 and ph0 are optional values by which the grid has been
!% rotated from geo coordinates.
implicit none

     character(len=2)   :: cpt
     type (tide_params) :: pars
     real(wp)           :: th0, ph0
     real(wp), pointer  :: th(:), ph(:)

     complex(cwp), allocatable, dimension(:) :: heq(:)

if (size(th)/=size(ph)) then
    write(*, '("** See function calc_heq_i")')
    stop
    return
endif

     pars = get_pars(cpt)

if ( (cpt == 'k2') .or. (cpt == 'm2') .or. (cpt == 'n2') .or. (cpt == 's2') .or. (cpt == 't2') ) then

    heq = pars%amp*pars%lovef*exp(-2*i*ph0) &
                *( cos(th0)*cos(th)*cos(ph)+sin(th0)*sin(th)-i*cos(th)*sin(ph) )**2

elseif ( (cpt == 'k1') .or. (cpt == 'p1') .or. (cpt == 'q1') .or. (cpt == 'o1') .or. (cpt == 't1') ) then

    heq = pars%amp*pars%lovef*exp(-i*ph0) &
                *( cos(2*th0)*sin(2*th)*cos(ph) + sin(2*th0)*(sin(th)**2) &
                  -sin(2*th0)*(cos(th)**2)*(cos(ph)**2) + i*sin(th0)*(cos(th)**2)*sin(2*ph) &
                  -i*cos(th0)*sin(2*th)*sin(ph) )

elseif ( (cpt == 'mm') .or. (cpt == 'mf') ) then

    heq = pars%amp*pars%lovef*(0.5 - 1.5*(cos(th0)*sin(th)-sin(th0)*cos(th)*cos(ph))**2)

endif


end subroutine calc_heq_i

!**********************************************************************************************************
!**********************************************************************************************************

function get_pars(cpt)

     character(len=2)   :: cpt
     type (tide_params) :: get_pars

!% returns the tidal get_pars%amplitude, love factor, and frequency
!% for the specified tidal component cpt, which is one of
!%
!%  m2, k1, s2, o1, p1, n2, mf, k2, mm, q1

select case(cpt)

       case ('m2')
       get_pars%amp=0.242334
       get_pars%lovef=0.693
       get_pars%omega0=1.405189d-4

       case ('k1')
       get_pars%amp=0.141565
       get_pars%lovef=0.736
       get_pars%omega0=0.7292117d-4

       case ('s2')
       get_pars%amp=0.112743
       get_pars%lovef=0.693
       get_pars%omega0=1.454441d-4

       case ('o1')
       get_pars%amp=0.100661
       get_pars%lovef=0.695
       get_pars%omega0=0.6759774d-4

       case ('p1')
       get_pars%amp=0.046848
       get_pars%lovef=0.706
       get_pars%omega0=0.7252295d-4

       case ('n2')
       get_pars%amp=0.046397
       get_pars%lovef=0.693
       get_pars%omega0=1.378797d-4

       case ('mf')
       get_pars%amp=0.042041
       get_pars%lovef=0.693
       get_pars%omega0=0.053234d-4

       case ('k2')
       get_pars%amp=0.030684
       get_pars%lovef=0.693
       get_pars%omega0=1.458423d-4

       case ('mm')
       get_pars%amp=0.022191
       get_pars%lovef=0.693
       get_pars%omega0=0.026392d-4

       case ('q1')
       get_pars%amp=0.019273
       get_pars%lovef=0.695
       get_pars%omega0=0.6495854d-4

       case ('t2')
       get_pars%amp=0.1
       get_pars%lovef=0.693
       get_pars%omega0=0

       case default
       get_pars%amp=0
       get_pars%lovef=0
       get_pars%omega0=0
       write(*, '("** Need to enter a valid tidal component.")')
       write(*, '("** See function get_pars")')

end select

end function get_pars

end module sal
