module baro_solver

!     use my_trigs
!     use generate_global_matrices
     use unsym_solvers
     use my_sparse_aggregate
     use my_sparse
     use sal
     use save_load
     use precisions, only: wp, cwp

     !use f90_kind      ! Kind-definition MODULE of the F-compiler
!     use sparse_utils  ! module for sparse matrix operations

!       External Subroutines
      external   dzasum
      real       dzasum

!       Solver
     character(len=*), parameter, private :: solver='umfpack'! umfpack or pardiso

     contains

subroutine baro_solver_linear(cpts, &
                               nu, nv, nh, np, latP, lonP, g, re, nph, nth, dir_grid, dir_cols, dir_mats)

    implicit none
!%   Calculates a barotropic tide. Uses u/v/h + volume transport formulation
!%
!%   H_u : H on the u-grid points
!%   H_v : H on the v-grid points
!%   H_h : H on the h-grid points
!%   ta_u : tau on the u-grid points
!%   ta_v : tau on the v-grid points
!%   ta_h : tau on the h-grid points

     integer, intent(in)     ::     nph, nth
     integer, intent(in)  :: nu, nv, nh, np
     real(wp), intent(in) :: latP, lonP
     real(wp), intent(in) :: g, re!, cdg, Q, beta
     character(len = *) :: dir_grid, dir_cols, dir_mats
     type (tide_params) :: pars

     integer ::      j
     real    ::      T1, T2 ! for measuring cpu time (NOT REAL TIME!)
     integer, allocatable :: hp(:, :)

     character(len=*) :: cpts
     character(len=2) :: cpt
     integer :: ncpts, ccpt
     integer :: iu(nu), iv(nv), ih(nh)

     type (triplet) :: mat
     type (triplet_cmplx) :: mat_coo_cmplx
     type (csr) :: mat_csr
     type (csr_cmplx) :: mat_csr_cmplx
     type (csc_cmplx) :: mat_csc_cmplx

     type (csr_cmplx) :: speye
     integer, allocatable :: bcdiag(:)
     complex(cwp), allocatable, dimension(:) :: rhs

     complex(cwp) :: uvh(np)
     complex(cwp) :: u(nu), v(nv), h(nh)

!==========================================================================================
write(*, '("====================================")')
write(*, '("Welcome to baro_solver_linear")')
write(*, '("====================================")')


ncpts=len(cpts)/2

     iu = (/ ( (j), j=1,nu ) /)
     iv = (/ ( (nu + j), j=1,nv ) /)
     ih = (/ ( (nu + nv + j), j=1,nh ) /)

!%==================================================
!% Load the sparse matrix generated by baro_uvhT_mat
!%==================================================
     call load_alloc_cmat(mat, dir_mats // 'temp/mat_init.dat')
     call load_alloc_vector(bcdiag, dir_mats // 'temp/bcdiag.dat')

! Convert mat from COO to CSR:
     call coo2csr(mat, mat_csr, mkl) ! use mkl or skit options
     call dealloc_sparse(mat)

!  %=============
!  % impose bcs:
!  %=============
write(*, '("Implementing boundary conditions... ")', advance = 'no')
!  if jj == 1
!    % local solve
!    load(colfile,'up','vp','hp');
!    mat=spdiags([up(:,3)==0; vp(:,3)==0; ones(nh,1)],0,np,np)*mat;
!    mat=mat+1e-4*spdiags([up(:,3)>0; vp(:,3)>0; zeros(nh,1)],0,np,np);
!    % set any coastal or open bcs to zero
!    rhs=spdiags([up(:,3)==0; vp(:,3)==0; ones(nh,1)],0,np,np)*rhs;
!    % now set the open bcs to prescribed values
!    load([flags.dir.file,'/',domain,'/',cpt,'_m0_prescribed'],'ub','vb');
!    rhs=rhs+1e-4*[(up(:,3)==2).*ub; (vp(:,3)==2).*vb; zeros(nh,1)];
!    clear up vp hp ub vb
!  elseif jj == 2

!mat=bcmat*mat; !fill the row of mat with zeroes for boundary variables
!rhs=bcmat*rhs; ! bcmat is already the way it should be!!!!!
     call diamulcsr(real(bcdiag,wp), mat_csr, skit) ! use mkl or skit options
!  now transform into cmplx matrix
     call init_sparse_csr_cmplx(mat_csr_cmplx,mat_csr%indi,mat_csr%indj,mat_csr%vals, &
                                mat_csr%ni, mat_csr%nj, mat_csr%nz)
      call dealloc_sparse(mat_csr)

  print *, "............. COMPLETE"

!     call init_sparse_0(mat_tmp, mat_csr_cmplx%ni,mat_csr_cmplx%nj, mat_csr_cmplx%nz)
!     call csrcoo_cmplx(mat_csr_cmplx%ni, 3, mat_csr_cmplx%nz,mat_csr_cmplx%vals,mat_csr_cmplx%indj,mat_csr_cmplx%indi, &
!                          mat_tmp%nz, mat_tmp%vals,mat_tmp%indi, mat_tmp%indj, ierr)
!      call save_sparse(mat_tmp, dir_mats // 'temp/mat_w_bc.dat')
!     call dealloc_sparse(mat_tmp)

      write(*, '( "Solving", i8, " x ", i8, " system with ", e10.3, " entries for:" )' ) mat_csr_cmplx%ni, &
                                                                 mat_csr_cmplx%nj, real(mat_csr_cmplx%nz)

!%==========================
!% solve for each component
!%==========================
do ccpt = 1, ncpts

     cpt=cpts(2*ccpt-1:2*ccpt)

     pars = get_pars(cpt)

!     mat = mat-i*omega0*speye(np)
      speye = speye_csr_cmplx(np, cmplx(0., -pars%omega0, kind=cwp) )
      call add_csr_cmplx(mat_csr_cmplx, cmplx(1., 0., kind=cwp), speye, mkl)

!     Save the final version of the matrix
      call csr2coo(mat_csr_cmplx, mat_coo_cmplx, mkl) ! use mkl or skit options (not 100% sure mkl works)
      call save_sparse(mat_coo_cmplx, dir_mats // 'mat_' // cpt //'.dat')
      call dealloc_sparse(mat_coo_cmplx)

!%=======================
!% calculate rhs forcing
!%=======================
     call baro_rhs(rhs, cpt, nu, nv, nh, latP, lonP, g, re, dir_cols, dir_grid, dir_mats)

!  %=======
!  % solve
!  %=======

  write(*, '(" ", a, "... " )', advance='no') cpt
  call CPU_Time(T1)

if (solver .eq. 'umfpack') then
!	USE UMFPACK TO SOLVE THE SYSTEM

      ! convert from csr to csc for umfpack solver (csc is convert to 0-based array)
        call csr2csc(mat_csr_cmplx, mat_csc_cmplx, mkl)! use mkl or skit options 
        call dealloc_sparse(mat_csr_cmplx)
!								   messages,filesave,loadsym,savenum
        call umfpack_unsym(mat_csc_cmplx%ni, mat_csc_cmplx, rhs, uvh, .false.,1,.false., .false.)
        call dealloc_sparse(mat_csc_cmplx)

elseif (solver .eq. 'pardiso') then
!	USE PARDISO TO SOLVE THE SYSTEM

      call pardiso_unsym(mat_csr_cmplx%ni, mat_csr_cmplx, rhs, uvh, .false.)
      call dealloc_sparse(mat_csr_cmplx)

else
      print *, "You must choose a valid solver: pardiso or umfpack"
      stop
end if

  call CPU_Time(T2)
  write(*, '("done in ", f5.1, "s.")') T2-T1

enddo

!  %=================
!  % output solution
!  %=================
    u = uvh(iu)
    v = uvh(iv)
    h = uvh(ih)

     call save_vector(u, dir_cols // 'u.dat')
     call save_vector(v, dir_cols // 'v.dat')
     call save_vector(h, dir_cols // 'h.dat')


write(*,*) "max tide hight", maxval(abs(h))
!  if flags.graphics == 1
!
!    %==============================
!    % plot global tides and errors
!    %==============================
     call load_alloc_mat_int(hp, dir_cols // 'hp.dat')

      OPEN(10,status='unknown',file='/home/amsta/amtvl/Desktop/scratch/Tides/data/sol_h.dat',form='UNFORMATTED')

      write(10) nph, nth, nh
      write(10) hp(:,1)
      write(10) hp(:,2)
      write(10) abs(h)
      CLOSE(10)


end subroutine baro_solver_linear

!==========================================================================================
!==========================================================================================

subroutine baro_rhs(rhs, cpt, nu, nv, nh, latP, lonP, g, re, dir_cols, dir_grid, dir_mats)

    implicit none
!
!% calculates the complex barotropic tidal forcing
!% for the given tidal component.

     character(len=2)     :: cpt
     integer, intent(in)  :: nu, nv, nh
     real(wp), intent(in) :: g, re, latP, lonP

     real(wp), allocatable :: ph_vg(:), ta_h(:) ! ta_ug(:)
     integer, allocatable  :: hp(:, :)
!     integer, allocatable :: up(:, :), vp(:, :), hp(:, :)
     integer, allocatable :: H_u(:), H_v(:)

     type (triplet) :: h2uddph, h2vddta

     integer ::      j
     integer ::      istatus
     integer :: iu(nu), iv(nv)
!     real    ::      T1, T2 ! for measuring cpu time (NOT REAL TIME!)

     complex(cwp), allocatable, dimension(:) :: rhs, heq
!     real(wp), allocatable, dimension(:) :: tmp2, ph_h, ph_u
     CHARACTER     matdescra(6)

     character(len = *) :: dir_grid, dir_cols, dir_mats

!%==============================================================
!% Load the necessary matrices:
!% h2uddph, h2vddta, u2hddph, v2hddta, u2vf, v2uf
!% and vectors:
!% ta_ug, ta_vg, ph_ug, ph_vg, ta_h, up, vp, hp, H_u, H_v
!%==============================================================
! load up, vp, hp
!     call load_alloc_mat_int(up, dir_cols // 'up.dat')
!     call load_alloc_mat_int(vp, dir_cols // 'vp.dat')
     call load_alloc_mat_int(hp, dir_cols // 'hp.dat')

     call load_alloc_vector(ph_vg, dir_grid // 'ph_vg.dat')
!     call load_alloc_vector(ta_ug, dir_grid // 'ta_ug.dat')
     call load_alloc_vector(ta_h, dir_cols // 'ta_h.dat')
! Load columns H_u, H_v
     call load_alloc_vector(H_u, dir_cols // 'H_u.dat')
     call load_alloc_vector(H_v, dir_cols // 'H_v.dat')

!	and someadditional for baro_rhs
     call load_alloc_cmat(h2uddph, dir_mats // 'h2uddph.dat')
     call load_alloc_cmat(h2vddta, dir_mats // 'h2vddta.dat')
!*************************************************************************

     iu = (/ ( (j), j=1,nu ) /)
     iv = (/ ( (j), j=1,nv ) /)

     allocate(rhs(nu+nv+nh), stat = istatus)
     rhs = 0.

     call calc_heq_h(heq, cpt, ta_h, ph_vg, hp, nh, latP, lonP)
     deallocate(ta_h, ph_vg)

     call save_vector(abs(heq), dir_cols // 'heq.dat')

!if flags.coor == 1
!  MERCATOR
matdescra(1) = 'G'

     call coo_vect_mul(h2uddph, heq, rhs(1:nu))
     call dealloc_sparse(h2uddph)
!call mkl_zcoomv('n', h2uddph%ni, h2uddph%nj, 1, matdescra, h2uddph%vals, h2uddph%indi, h2uddph%indj, h2uddph%nz, heq, 0, rhs(1:nu))

     call coo_vect_mul(h2vddta, heq, rhs(nu+1:nu+nv))
     call dealloc_sparse(h2vddta)
!call mkl_zcoomv('n', h2vddta%ni, h2vddta%nj,1,matdescra,h2vddta%vals,h2vddta%indi,h2vddta%indj,h2vddta%nz, heq, 0, rhs(nu+1:nu+nv))

!    *H_u or *H_v for volume transport formulation
     rhs(1:nu) = (g/re)*H_u*rhs(1:nu)
     rhs(nu+1:nu+nv) = (g/re)*H_v*rhs(nu+1:nu+nv)

     call save_vector(rhs, dir_cols // 'rhs.dat')

!elseif flags.coor == 2
!  % lat/lon; ta=th.
!  rhs(iu)=(g/re)*(1./cos(ta_u)).*( h2uddph*heq_h );
!  rhs(iv)=(g/re)*h2vddta*heq_h;
!end
!
!if flags.baro.num.uvform == 2
!  load(colfile,'H_u','H_v');
!  rhs(iu)=H_u.*rhs(iu);
!  rhs(iv)=H_v.*rhs(iv);
!end

end subroutine baro_rhs

!**********************************************************************************************************
!**********************************************************************************************************

end module baro_solver



