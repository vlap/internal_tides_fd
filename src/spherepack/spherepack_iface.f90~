module spherepack_iface

     use precisions, only: wp, cwp
!
! fortran95 interface for spherepack.
! For regular and gaussian lat/lon grids.
!
! requires NCAR's SPHEREPACK 3.2
! (http://www2.cisl.ucar.edu/resources/legacy/spherepack)
!
! Version 1.2 - February, 2012
! Jeff Whitaker <jeffrey.s.whitaker@noaa.gov>

! Important Details:

! The grid and spectral arrays must be rank 2 and rank 1, respectively.
! Passing array sections is OK.

! The gridded data is assumed to be oriented such that i=1 is the 
! Greenwich meridian and j=1 is the northernmost point. Grid indices
! increase eastward and southward. If nlat is odd the equator will be
! included as a grid point. If nlat is even the equator will lie half
! way between points nlat/2 and (nlat/2)+1. nlat must be at least 3. 
! The grid increment in longitude is 2*pi/nlon radians. For example,
! nlon = 72 for a five degree grid. nlon must be greater than or 
! equal to 4. The efficiency of the computation is improved when nlon
! is a product of small prime numbers. 

! The spectral data is assumed to be in a complex array of dimension
! (MTRUNC+1)*(MTRUNC+2)/2. MTRUNC is the triangular truncation limit
! (MTRUNC = 42 for T42). MTRUNC must be <= nlat-1. Coefficients are
! ordered so that first (nm=1) is m=0,n=0, second is m=0,n=1, 
! nm=mtrunc is m=0,n=mtrunc, nm=mtrunc+1 is m=1,n=1, etc.
! In Fortran95 syntax, values of m (degree) and n (order) as a function
! of the index nm are: 

! integer, dimension((mtrunc+1)*(mtrunc+2)/2) :: indxm,indxn
! indxm = (/((m,n=m,mtrunc),m=0,mtrunc)/)
! indxn = (/((n,n=m,mtrunc),m=0,mtrunc)/)

! Conversely, the index nm as a function of m and n is: 
! nm = sum((/(i,i=mtrunc+1,mtrunc-m+2,-1)/))+n-m+1

! The associated legendre polynomials are normalized so that the
! integral (pbar(n,m,theta)**2)*sin(theta) on the interval theta=0
! to theta=pi is 1, where: 

! pbar(m,n,theta) = sqrt((2*n+1)*factorial(n-m)/(2*factorial(n+m))) *
! sin(theta)**m/(2**n*factorial(n)) times the (n+m)th derivative of
! (x**2-1)**n with respect to x=cos(theta) 

! note: theta = 0.5*pi - phi, where phi is latitude and theta is colatitude.
! Therefore, cos(theta) = sin(phi) and sin(theta) = cos(phi). 
! Note that pbar(0,0,theta)=sqrt(2)/2, and 
! pbar(1,0,theta)=0.5*sqrt(6.)*sin(lat). 
!----------------------------------------------------------------------------


! logical variables set to .FALSE. after work arrays initialized on
! first call. If nlon or nlat changes (as determined by size of
! input array), work arrays are real located and
! recomputed.

      implicit none 
      private 
      public :: &
      grdtospec_reg,spectogrd_reg,cleanup_reg,&
      grdtospec_gau,spectogrd_gau,cleanup_gau,&
      grdtospec,spectogrd,cleanup

      integer, save :: saved_nlon_reg_spectogrd = -1  
      integer, save :: saved_nlat_reg_spectogrd = -1  
      integer, save :: saved_nlon_reg_grdtospec = -1  
      integer, save :: saved_nlat_reg_grdtospec = -1  
      integer, save :: saved_nlon_gau_spectogrd = -1  
      integer, save :: saved_nlat_gau_spectogrd = -1  
      integer, save :: saved_nlon_gau_grdtospec = -1  
      integer, save :: saved_nlat_gau_grdtospec = -1  
      logical, save :: lfrst_grdtospec_reg=.TRUE.
      logical, save :: lfrst_spectogrd_reg=.TRUE.
      logical, save :: lfrst_grdtospec_gau=.TRUE.
      logical, save :: lfrst_spectogrd_gau=.TRUE.

! work arrays are allocated in module subroutines when above
! logical variables are .TRUE., or when nlon or nlat change.

      real(wp), dimension(:), allocatable, save :: wshaes,wshses,wvhaes,wvhses
      real(wp), dimension(:), allocatable, save :: wshags,wshsgs,wvhags,wvhsgs

      contains
!**********************************************************************************************************
      subroutine grdtospec(datagrid,dataspec,gridtype)
      real(wp), dimension(:,:), intent(in) :: datagrid
      complex(cwp), dimension(:), intent(out) :: dataspec
      character(*), intent(in), optional :: gridtype
      if (present(gridtype)) then
      if (gridtype .eq. 'GAU') then
           call  grdtospec_gau(datagrid,dataspec)
      else if (gridtype .eq. 'REG') then
           call  grdtospec_reg(datagrid,dataspec)
      else
           write(6,*) 'SUBROUTINE GRDTOSPEC:'
           write(6,*) 'optional argument gridtype = ',gridtype
           write(6,*) 'must be either REG or GAU (default REG)'
           stop
      end if
      else
           call  grdtospec_reg(datagrid,dataspec)
      endif
      end subroutine grdtospec
!**********************************************************************************************************
      subroutine spectogrd(dataspec,datagrid,gridtype)
      real(wp), dimension(:,:), intent(out) :: datagrid
      complex(cwp), dimension(:), intent(in) :: dataspec
      character(*), intent(in), optional :: gridtype
      if (present(gridtype)) then
      if (gridtype .eq. 'GAU') then
           call  spectogrd_gau(dataspec,datagrid)
      else if (gridtype .eq. 'REG') then
           call  spectogrd_reg(dataspec,datagrid)
      else
           write(6,*) 'SUBROUTINE SPECTOGRD:'
           write(6,*) 'optional argument gridtype = ',gridtype
           write(6,*) 'must be either REG or GAU (default REG)'
           stop
      end if
      else
           call  spectogrd_reg(dataspec,datagrid)
      endif
      end subroutine spectogrd
!**********************************************************************************************************
      subroutine cleanup(gridtype)
      character(*), intent(in), optional :: gridtype
      if (present(gridtype)) then
      if (gridtype .eq. 'GAU') then
           call cleanup_gau
      else if (gridtype .eq. 'REG') then
           call cleanup_reg
      else
           write(6,*) 'SUBROUTINE CLEANUP:'
           write(6,*) 'optional argument gridtype = ',gridtype
           write(6,*) 'must be either REG or GAU (default REG)'
           stop
      end if
      else
           call cleanup_reg
      endif
      end subroutine cleanup
!**********************************************************************************************************
      subroutine grdtospec_reg(datagrid,dataspec)

! converts gridded input array (datagrid) to complex spectral coefficients
! (dataspec).

      real(wp), dimension(:,:), intent(in) :: datagrid
      complex(cwp), dimension(:), intent(out) :: dataspec

      real(wp), dimension((4*size(datagrid,1)+2)*size(datagrid,2)) :: work
      double precision, dimension(2*(size(datagrid,2)+1)) :: dwork
      real(wp), dimension(size(datagrid,2),size(datagrid,1)) :: temp
      real(wp), dimension(size(datagrid,2),size(datagrid,2)) :: a,b
      integer nlon,nlat,lwork,ldwork,ntrunc,l1,l2,lshaes,ierror,m,n

! compute array dimensions and infer truncation limit
! from size of spectral arrays.


      nlon = size(datagrid,1)
      nlat = size(datagrid,2)
      if (nlon .ne. saved_nlon_reg_grdtospec .or. nlat .ne. saved_nlat_reg_grdtospec) then
          lfrst_grdtospec_reg = .TRUE.
          saved_nlon_reg_grdtospec = nlon
          saved_nlat_reg_grdtospec = nlat
      end if
      lwork = size(work)
      ldwork = size(dwork)
      ntrunc = nint((-1.+sqrt(1+8*float(size(dataspec))))/2.)-1


! initialize work array wshaes for spherical harmonic analysis.
! only done when lfrst_grdtospec_reg = .T.

      if (lfrst_grdtospec_reg) then

      if (allocated(wshaes)) deallocate(wshaes)

      if (mod(nlon,2) .eq. 0) then
         l1 = min0(nlat,(nlon+2)/2) 
      else
         l1 = min0(nlat,(nlon+1)/2)
      end if
      if (mod(nlat,2) .eq. 0) then
         l2 = nlat/2      
      else
         l2 = (nlat+1)/2
      end if

      lshaes = (l1*l2*(nlat+nlat-l1+1))/2+nlon+15

      allocate(wshaes(lshaes))

      call shaesi(nlat,nlon,wshaes,lshaes, &
          work,lwork,dwork,ldwork,ierror)
      if(ierror .ne. 0) write(*,1001) ierror
 1001 format(' error',i4,' in shaesi')
      lfrst_grdtospec_reg = .FALSE.
      else
      lshaes = size(wshaes,1)
      endif

! transpose data.

      temp = transpose(datagrid)

! spherical harmonic analysis.

      call shaes(nlat,nlon,0,1,temp,nlat,nlon,a,b,nlat,nlat, &
                 wshaes,lshaes,work,lwork,ierror)
      if(ierror .ne. 0) write(*,1003) ierror
 1003  format(' error',i4,' in shaes')
 
! fill complex array dataspec with result.

      dataspec = cmplx( 0.5*(/((a(m,n),n=m,ntrunc+1),m=1,ntrunc+1)/), &
                        0.5*(/((b(m,n),n=m,ntrunc+1),m=1,ntrunc+1)/) )
 
      end subroutine grdtospec_reg
!**********************************************************************************************************
      subroutine grdtospec_gau(datagrid,dataspec)

! converts gridded input array (datagrid) to complex spectral coefficients
! (dataspec).

      real(wp), dimension(:,:), intent(in) :: datagrid
      complex, dimension(:), intent(out) :: dataspec

      real(wp), dimension((4*size(datagrid,1)+2)*size(datagrid,2)) :: work
      double precision, dimension((3*size(datagrid,2)*(size(datagrid,2)+3)+2)/2) :: dwork
      real(wp), dimension(size(datagrid,2),size(datagrid,1)) :: temp
      real(wp), dimension(size(datagrid,2),size(datagrid,2)) :: a,b

      integer nlon,nlat,lwork,ldwork,ntrunc,l1,l2,lshags,ierror,m,n

! compute array dimensions and infer truncation limit
! from size of spectral arrays.


      nlon = size(datagrid,1)
      nlat = size(datagrid,2)
      if (nlon .ne. saved_nlon_gau_grdtospec .or. nlat .ne. saved_nlat_gau_grdtospec) then
          lfrst_grdtospec_gau = .TRUE.
          saved_nlon_gau_grdtospec = nlon
          saved_nlat_gau_grdtospec = nlat
      end if
      lwork = size(work)
      ldwork = size(dwork)
      ntrunc = nint((-1.+sqrt(1+8*float(size(dataspec))))/2.)-1


! initialize work array wshags for spherical harmonic analysis.
! only done when lfrst_grdtospec_gau = .T.

      if (lfrst_grdtospec_gau) then

      if (allocated(wshags)) deallocate(wshags)

      if (mod(nlon,2) .eq. 0) then
         l1 = min0(nlat,(nlon+2)/2) 
      else
         l1 = min0(nlat,(nlon+1)/2) 
      end if
      if (mod(nlat,2) .eq. 0) then
         l2 = nlat/2      
      else
         l2 = (nlat+1)/2
      end if

      lshags = nlat*(3*(l1+l2)-2)+(l1-1)*(l2*(2*nlat-l1)-3*l1)/2+nlon+15

      allocate(wshags(lshags))

      call shagsi(nlat,nlon,wshags,lshags, &
          work,lwork,dwork,ldwork,ierror)
      if(ierror .ne. 0) write(*,1001) ierror
 1001 format(' error',i4,' in shagsi')
      lfrst_grdtospec_gau = .FALSE.
      else
      lshags = size(wshags,1)
      endif

! transpose data.

      temp = transpose(datagrid)

! spherical harmonic analysis.

      call shags(nlat,nlon,0,1,temp,nlat,nlon,a,b,nlat,nlat, &
                 wshags,lshags,work,lwork,ierror)
      if(ierror .ne. 0) write(*,1003) ierror
 1003  format(' error',i4,' in shags')
 
! fill complex array dataspec with result.

      dataspec = cmplx( 0.5*(/((a(m,n),n=m,ntrunc+1),m=1,ntrunc+1)/), &
                        0.5*(/((b(m,n),n=m,ntrunc+1),m=1,ntrunc+1)/) )
 
      end subroutine grdtospec_gau
!**********************************************************************************************************
      subroutine spectogrd_reg(dataspec,datagrid)
      
! converts complex spectral coefficients (dataspec) to 
! gridded data array (datagrid).


      real(wp), dimension(:,:), intent(inout) :: datagrid
      complex(cwp), dimension(:), intent(in) :: dataspec

      real(wp), dimension((4*size(datagrid,1)+2)*size(datagrid,2)) :: work
      double precision, dimension(2*(size(datagrid,2)+1)) :: dwork
      real(wp), dimension(size(datagrid,2),size(datagrid,1)) :: temp
      real(wp), dimension(size(datagrid,2),size(datagrid,2)) :: a,b

      integer nlon,nlat,lwork,ldwork,ntrunc,l1,l2,lshses,ierror,m,n,nn,i
      
! compute array dimensions and infer truncation limit
! from size of dataspec.

      nlon = size(datagrid,1)
      nlat = size(datagrid,2)
      if (nlon .ne. saved_nlon_reg_spectogrd .or. nlat .ne. saved_nlat_reg_spectogrd) then
          lfrst_spectogrd_reg = .TRUE.
          saved_nlon_reg_spectogrd = nlon
          saved_nlat_reg_spectogrd = nlat
      else
      end if
      lwork = size(work)
      lwork = size(work)
      ldwork = size(dwork)
      ntrunc = nint((-1.+sqrt(1+8*float(size(dataspec))))/2.)-1

! compute work array wshses for spherical harmonic synthesis.
! only done when lfrst_spectogrd_reg = .T.

      if (lfrst_spectogrd_reg) then

      if (allocated(wshses)) deallocate(wshses)

      if (mod(nlon,2) .eq. 0) then
         l1 = min0(nlat,(nlon+2)/2) 
      else
         l1 = min0(nlat,(nlon+1)/2) 
      end if
      if (mod(nlat,2) .eq. 0) then
         l2 = nlat/2        
      else
         l2 = (nlat+1)/2    
      end if

      lshses = (l1*l2*(nlat+nlat-l1+1))/2+nlon+15

      allocate(wshses(lshses))

      call shsesi(nlat,nlon,wshses,lshses,work,lwork, &
                  dwork,ldwork,ierror)
      if(ierror .ne. 0) write(*,1001) ierror
 1001 format(' error',i4,' in shsesi')
      lfrst_spectogrd_reg = .FALSE.
      else
      lshses = size(wshses,1)
      endif

! fill two real arrays (a,b) with contents of dataspec.

      a = 0.
      b = 0.
      do m=1,ntrunc+1
      do n=m,ntrunc+1
         nn = sum((/(i,i=ntrunc+1,ntrunc-m+3,-1)/))+n-m+1
         a(m,n) = 2.*real(dataspec(nn))
         b(m,n) = 2.*aimag(dataspec(nn))
      enddo
      enddo

! spherical harmonic synthesis.

      call shses(nlat,nlon,0,1,temp,nlat,nlon,a,b,nlat,nlat, &
                 wshses,lshses,work,lwork,ierror)
      if(ierror .ne. 0) write(*,1003) ierror
 1003  format(' error',i4,' in shses')

! transpose data.

      datagrid = transpose(temp)
 
      end subroutine spectogrd_reg
!**********************************************************************************************************
      subroutine spectogrd_gau(dataspec,datagrid)
      
! converts complex spectral coefficients (dataspec) to 
! gridded data array (datagrid).


      real(wp), dimension(:,:), intent(out) :: datagrid
      complex, dimension(:), intent(in) :: dataspec

      real(wp), dimension((4*size(datagrid,1)+2)*size(datagrid,2)) :: work
      double precision, dimension((3*size(datagrid,2)*(size(datagrid,2)+3)+2)/2) :: dwork
      real(wp), dimension(size(datagrid,2),size(datagrid,1)) :: temp
      real(wp), dimension(size(datagrid,2),size(datagrid,2)) :: a,b

      integer nlon,nlat,lwork,ldwork,ntrunc,l1,l2,lshsgs,ierror,m,n,nn,i
      
! compute array dimensions and infer truncation limit
! from size of dataspec.

      nlon = size(datagrid,1)
      nlat = size(datagrid,2)
      if (nlon .ne. saved_nlon_gau_spectogrd .or. nlat .ne. saved_nlat_gau_spectogrd) then
          lfrst_spectogrd_gau = .TRUE.
          saved_nlon_gau_spectogrd = nlon
          saved_nlat_gau_spectogrd = nlat
      end if
      lwork = size(work)
      lwork = size(work)
      ldwork = size(dwork)
      ntrunc = nint((-1.+sqrt(1+8*float(size(dataspec))))/2.)-1

! compute work array wshsgs for spherical harmonic synthesis.
! only done when lfrst_spectogrd_gau = .T.

      if (lfrst_spectogrd_gau) then

      if (allocated(wshsgs)) deallocate(wshsgs)

      if (mod(nlon,2) .eq. 0) then
         l1 = min0(nlat,(nlon+2)/2) 
      else
         l1 = min0(nlat,(nlon+1)/2) 
      end if
      if (mod(nlat,2) .eq. 0) then
         l2 = nlat/2        
      else
         l2 = (nlat+1)/2    
      end if

      lshsgs = nlat*(3*(l1+l2)-2)+(l1-1)*(l2*(2*nlat-l1)-3*l1)/2+nlon+15

      allocate(wshsgs(lshsgs))

      call shsgsi(nlat,nlon,wshsgs,lshsgs,work,lwork, &
                  dwork,ldwork,ierror)
      if(ierror .ne. 0) write(*,1001) ierror
 1001 format(' error',i4,' in shsgsi')
      lfrst_spectogrd_gau = .FALSE.
      else
      lshsgs = size(wshsgs,1)
      endif

! fill two real arrays (a,b) with contents of dataspec.

      a = 0.
      b = 0.
      do m=1,ntrunc+1
      do n=m,ntrunc+1
         nn = sum((/(i,i=ntrunc+1,ntrunc-m+3,-1)/))+n-m+1
         a(m,n) = 2.*real(dataspec(nn))
         b(m,n) = 2.*aimag(dataspec(nn))
      enddo
      enddo

! spherical harmonic synthesis.

      call shsgs(nlat,nlon,0,1,temp,nlat,nlon,a,b,nlat,nlat, &
                 wshsgs,lshsgs,work,lwork,ierror)
      if(ierror .ne. 0) write(*,1003) ierror
 1003  format(' error',i4,' in shsgs')

! transpose data.

      datagrid = transpose(temp)
 
      end subroutine spectogrd_gau
!**********************************************************************************************************
      subroutine cleanup_gau

! cleanup memory allocations when done with module.

      if (allocated(wshags)) deallocate(wshags)
      if (allocated(wshsgs)) deallocate(wshsgs)
      if (allocated(wvhags)) deallocate(wvhags)
      if (allocated(wvhsgs)) deallocate(wvhsgs)
      saved_nlat_gau_grdtospec = -1
      saved_nlon_gau_grdtospec = -1
      saved_nlat_gau_spectogrd = -1
      saved_nlon_gau_spectogrd = -1
      lfrst_grdtospec_gau = .TRUE.
      lfrst_spectogrd_gau = .TRUE.

      end subroutine cleanup_gau
!**********************************************************************************************************
      subroutine cleanup_reg

! cleanup memory allocations when done with module.

      if (allocated(wshaes)) deallocate(wshaes)
      if (allocated(wshses)) deallocate(wshses)
      if (allocated(wvhaes)) deallocate(wvhaes)
      if (allocated(wvhses)) deallocate(wvhses)
      saved_nlat_reg_grdtospec = -1
      saved_nlon_reg_grdtospec = -1
      saved_nlat_reg_spectogrd = -1
      saved_nlon_reg_spectogrd = -1
      lfrst_grdtospec_reg = .TRUE.
      lfrst_spectogrd_reg = .TRUE.

      end subroutine cleanup_reg
!**********************************************************************************************************

! that's it!

      end module spherepack_iface
