module my_sparse_aggregate

     use precisions, only: wp, cwp
     use my_sparse


     character, parameter :: mkl = 'm'
     character, parameter :: skit = 's'

!==========================================================================================
!**************************** INTERFACES **************************************************
!==========================================================================================
!---------------------------- CONVERT COO2CSR SPARSE ---------------------------------------
     interface coo2ful
          module procedure conv_coo2ful
          module procedure conv_coo2ful_cmplx
     end interface
!---------------------------- CONVERT COO2CSR SPARSE ---------------------------------------
     interface coo2csr
          module procedure conv_coo2csr
          module procedure conv_coo2csr_cmplx
     end interface  
!---------------------------- CONVERT CSR2COO SPARSE ----------------------------------
     interface csr2coo
!          module procedure conv_csr2coo
          module procedure conv_csr2coo_cmplx
     end interface  
!---------------------------- CONVERT CSR2CSC SPARSE ----------------------------------
     interface csr2csc
!          module procedure conv_csr2csc
          module procedure conv_csr2csc_cmplx
     end interface  
!---------------------------- MULT DIAG BY SPARSE -------------------------------------
     interface diamulcsr
          module procedure mul_diacsr
          module procedure mul_diacsr_cmplx
     end interface
!---------------------------- TRIPLET VEC MULT SPARSE ---------------------------------
     interface coomulvec
          module procedure mul_coo_vec_cmplx
     end interface
!==========================================================================================

contains
!==========================================================================================
subroutine conv_coo2ful(mat_coo, mat_ful)

implicit none

     type (triplet)			:: mat_coo
     real(wp),allocatable	:: mat_ful(:,:)
	 integer :: istat, c

    allocate(mat_ful(mat_coo%ni, mat_coo%nj), stat = istat)

    mat_ful = 0

    do c = 1,mat_coo%nz
    	mat_ful(mat_coo%indi(c),mat_coo%indj(c)) = mat_coo%vals(c)
    enddo

end subroutine conv_coo2ful

!==========================================================================================
subroutine conv_coo2ful_cmplx(mat_coo, mat_csr_cmplx, method)

implicit none

     type (triplet_cmplx)		:: mat_coo
     complex(cwp),allocatable	:: mat_ful(:,:)
	 integer :: istat, c

    allocate(mat_ful(mat_coo%ni, mat_coo%nj), stat = istat)

    mat_ful = 0

    do c = 1,mat_coo%nz
    	mat_ful(mat_coo%indi(c),mat_coo%indj(c)) = mat_coo%vals(c)
    enddo

end subroutine conv_coo2ful_cmplx
!==========================================================================================

!==========================================================================================
subroutine conv_coo2csr(mat_coo, mat_csr, method)

implicit none

     type (triplet) :: mat_coo
     type (csr) :: mat_csr
     character :: method

     integer,dimension(:),allocatable :: iwork
     integer :: info_mkl, job(8), istat

     call init_sparse_0(mat_csr, mat_coo%ni, mat_coo%nj, mat_coo%nz)

if (method == skit) then

!sparskit convert COO to CSR:
     call coocsr(mat_coo%ni,mat_coo%nz,mat_coo%vals,mat_coo%indi, mat_coo%indj, &
                       mat_csr%vals,mat_csr%indj,mat_csr%indi)
!sparskit sort CSR with column index incr within each row:
     allocate(iwork(2*mat_csr%nz),stat=istat)
     call csort(mat_csr%ni,mat_csr%vals,mat_csr%indj,mat_csr%indi,iwork,.true.)

else

! MKL convert triplet/COO to CSR format
job(1)=2 ! convert COO to CSR and sort
job(2)=1 ! 1-based indexing in CSR
job(3)=1 ! 1-based indexing in COO
job(5)=mat_coo%nz ! # of non-zeros in matrix A
job(6)=0 ! Fill all CSR arrays

     call mkl_dcsrcoo(job, mat_coo%ni, mat_csr%vals, mat_csr%indj, mat_csr%indi, mat_csr%nz, &
                 mat_coo%vals, mat_coo%indi, mat_coo%indj, info_mkl)
endif

end subroutine conv_coo2csr

!==========================================================================================
! strange problem with mkl option
subroutine conv_coo2csr_cmplx(mat_coo, mat_csr_cmplx, method)

implicit none

     type (triplet) :: mat_coo
     type (csr_cmplx) :: mat_csr_cmplx
     character :: method

     integer,dimension(:),allocatable :: iwork
     integer :: info_mkl, job(8), istat

     call init_sparse_0(mat_csr_cmplx, mat_coo%ni, mat_coo%nj, mat_coo%nz)

if (method == skit) then

!sparskit convert COO to CSR:
     call coocsr_cmplx(mat_coo%ni,mat_coo%nz,mat_coo%vals,mat_coo%indi, mat_coo%indj, &
                       mat_csr_cmplx%vals,mat_csr_cmplx%indj,mat_csr_cmplx%indi)
!sparskit sort CSR with column index incr within each row:
     allocate(iwork(2*mat_csr_cmplx%nz),stat=istat)
     call csort_cmplx(mat_csr_cmplx%ni,mat_csr_cmplx%vals,mat_csr_cmplx%indj,mat_csr_cmplx%indi,iwork,.true.)

else

! MKL convert triplet/COO to CSR format
job(1)=2 ! convert COO to CSR and sort
job(2)=1 ! 1-based indexing in CSR
job(3)=1 ! 1-based indexing in COO
job(5)=mat_coo%nz ! # of non-zeros in matrix A
job(6)=0 ! Fill all CSR arrays

     call mkl_zcsrcoo(job, mat_coo%ni, mat_csr_cmplx%vals, mat_csr_cmplx%indj, mat_csr_cmplx%indi, mat_csr_cmplx%nz, &
                 cmplx(mat_coo%vals, 0., cwp), mat_coo%indi, mat_coo%indj, info_mkl)
endif

end subroutine conv_coo2csr_cmplx
!==========================================================================================
!==========================================================================================
subroutine conv_csr2coo_cmplx(mat_csr_cmplx, mat_coo_cmplx, method)

implicit none

     type (triplet_cmplx) :: mat_coo_cmplx
     type (csr_cmplx) :: mat_csr_cmplx
     character :: method

     integer :: info_mkl, job(8), ierr

     call init_sparse_0(mat_coo_cmplx, mat_csr_cmplx%ni, mat_csr_cmplx%nj, mat_csr_cmplx%nz)

if (method == skit) then
! sparskit convert CSR to COO format
     call csrcoo_cmplx(mat_csr_cmplx%ni, 3, mat_csr_cmplx%nz,mat_csr_cmplx%vals,mat_csr_cmplx%indj, mat_csr_cmplx%indi, &
                       mat_coo_cmplx%nz, mat_coo_cmplx%vals,mat_coo_cmplx%indi,mat_coo_cmplx%indj, ierr)
else
! MKL convert CSR to triplet/COO format
job(1)=0 ! convert CSR to COO
job(2)=1 ! 1-based indexing in CSR
job(3)=1 ! 1-based indexing in COO
job(5)=mat_coo_cmplx%nz ! # of non-zeros in matrix A
job(6)=3 ! all arrays rowind, colind, acoo are filled in for the output storage.

     call mkl_zcsrcoo(job, mat_csr_cmplx%ni, mat_csr_cmplx%vals, mat_csr_cmplx%indj, mat_csr_cmplx%indi, mat_csr_cmplx%nz, &
                      mat_coo_cmplx%vals, mat_coo_cmplx%indi, mat_coo_cmplx%indj, info_mkl)

endif

end subroutine conv_csr2coo_cmplx
!==========================================================================================
!==========================================================================================
subroutine conv_csr2csc_cmplx(mat_csr_cmplx, mat_csc_cmplx, method)

! IMPORTANT: mat_csc_cmplx is converted to 0-based for umfpack

implicit none

     type (csc_cmplx) :: mat_csc_cmplx
     type (csr_cmplx) :: mat_csr_cmplx
     character :: method

     integer :: info_mkl, job(8)

     call init_sparse_0(mat_csc_cmplx, mat_csr_cmplx%ni, mat_csr_cmplx%nj, mat_csr_cmplx%nz)

if (method == skit) then
! sparskit convert CSR to CSC format
      call csrcsc_cmplx (mat_csr_cmplx%ni,1,1,mat_csr_cmplx%vals,mat_csr_cmplx%indj,mat_csr_cmplx%indi,&
                   mat_csc_cmplx%vals,mat_csc_cmplx%indi,mat_csc_cmplx%indj)
! convert from 1-based to 0-based
      mat_csc_cmplx%indi = mat_csc_cmplx%indi - 1
      mat_csc_cmplx%indj = mat_csc_cmplx%indj - 1
else
! MKL convert CSR to CSC format
job(1)=0 ! convert CSR to CSC
job(2)=1 ! 1-based indexing in CSR
job(3)=0 ! 1-based indexing in CSC
!job(5)=mat_csc_cmplx%nz ! # of non-zeros in matrix A
job(6)=1 ! all output arrays are filled in for the output storage.

     call mkl_zcsrcsc(job, mat_csr_cmplx%ni, mat_csr_cmplx%vals, mat_csr_cmplx%indj, mat_csr_cmplx%indi, &
                      mat_csc_cmplx%vals,  mat_csc_cmplx%indi, mat_csc_cmplx%indj, info_mkl)
endif

end subroutine conv_csr2csc_cmplx
!==========================================================================================
!==========================================================================================
subroutine mul_diacsr(diag, a_csr, method, b_csr)
! B = Diag * A
implicit none

     type (csr)           :: a_csr, tmp_csr
     type (csr), optional :: b_csr
     real(wp)             :: diag(:)
     character :: method

     integer :: request, sort, info_mkl, j
     character  trans
     integer, allocatable :: tmp(:)

if (method == skit) then

!sparskit: mat=bcmat*mat
    if (present(b_csr)) then
        call init_sparse_0(b_csr, a_csr%ni, a_csr%nj, a_csr%nz)
        call diamua(a_csr%ni, 1, a_csr%vals, a_csr%indj, a_csr%indi, real(diag, kind=wp), &
                                       b_csr%vals, b_csr%indj, b_csr%indi)
    else
       call diamua(a_csr%ni, 0, a_csr%vals, a_csr%indj, a_csr%indi, real(diag, kind=wp), &
                                       a_csr%vals, a_csr%indj, a_csr%indi)
    endif
else

!mkl: mat=bcmat*mat
trans = 'n'
request = 0
sort = 0

     allocate(tmp(a_csr%nj))
     tmp = (/ ( (j), j=1,a_csr%nj) /)

    if (present(b_csr)) then
          call init_sparse_0(b_csr, a_csr%ni, a_csr%nj, a_csr%nz)
          call mkl_dcsrmultcsr(trans, request, sort, a_csr%ni, a_csr%nj, a_csr%nj, &
                     diag, tmp, (/ tmp, a_csr%nj+1/), &
                     a_csr%vals, a_csr%indj, a_csr%indi, &
                     b_csr%vals, b_csr%indj, b_csr%indi, a_csr%nz, info_mkl)
    else
          call init_sparse_0(tmp_csr, a_csr%ni, a_csr%nj, a_csr%nz)
          call mkl_dcsrmultcsr(trans, request, sort, a_csr%ni, a_csr%nj, a_csr%nj, &
                     diag, tmp, (/ tmp, a_csr%nj+1/), &
                     a_csr%vals, a_csr%indj, a_csr%indi, &
                     tmp_csr%vals, tmp_csr%indj, tmp_csr%indi, tmp_csr%nz, info_mkl)
! copy result back to a_csr
          a_csr = tmp_csr
    endif

endif

end subroutine mul_diacsr
!==========================================================================================
!==========================================================================================
subroutine mul_diacsr_cmplx(diag, a_csr_cmplx, method, b_csr_cmplx)
! B = Diag * A
implicit none

     type (csr_cmplx)           :: a_csr_cmplx, tmp_csr_cmplx
     type (csr_cmplx), optional :: b_csr_cmplx
     real(wp)                   :: diag(:)
     character :: method

     integer :: request, sort, info_mkl, j
     character  trans
     integer, allocatable :: ones(:)

if (method == skit) then

!sparskit: mat=bcmat*mat
    if (present(b_csr_cmplx)) then
        call init_sparse_0(b_csr_cmplx, a_csr_cmplx%ni, a_csr_cmplx%nj, a_csr_cmplx%nz)
        call diamua_cmplx(a_csr_cmplx%ni, 1, a_csr_cmplx%vals, a_csr_cmplx%indj, a_csr_cmplx%indi, real(diag, kind=wp), &
                                       b_csr_cmplx%vals, b_csr_cmplx%indj, b_csr_cmplx%indi)
    else
       call diamua_cmplx(a_csr_cmplx%ni, 0, a_csr_cmplx%vals, a_csr_cmplx%indj, a_csr_cmplx%indi, real(diag, kind=wp), &
                                       a_csr_cmplx%vals, a_csr_cmplx%indj, a_csr_cmplx%indi)
    endif
else

!mkl: mat=bcmat*mat
trans = 'n'
request = 0
sort = 0

     allocate(ones(a_csr_cmplx%nj))
     ones = (/ ( (j), j=1,a_csr_cmplx%nj) /)

    if (present(b_csr_cmplx)) then
          call init_sparse_0(b_csr_cmplx, a_csr_cmplx%ni, a_csr_cmplx%nj, a_csr_cmplx%nz)
          call mkl_zcsrmultcsr(trans, request, sort, a_csr_cmplx%ni, a_csr_cmplx%nj, a_csr_cmplx%nj, &
                     cmplx(diag, 0., cwp), ones, (/ ones, a_csr_cmplx%nj+1/), &
                     a_csr_cmplx%vals, a_csr_cmplx%indj, a_csr_cmplx%indi, &
                     b_csr_cmplx%vals, b_csr_cmplx%indj, b_csr_cmplx%indi, a_csr_cmplx%nz, info_mkl)
    else
          call init_sparse_0(tmp_csr_cmplx, a_csr_cmplx%ni, a_csr_cmplx%nj, a_csr_cmplx%nz)
          call mkl_zcsrmultcsr(trans, request, sort, a_csr_cmplx%ni, a_csr_cmplx%nj, a_csr_cmplx%nj, &
                     cmplx(diag, 0., cwp), ones, (/ ones, a_csr_cmplx%nj+1/), &
                     a_csr_cmplx%vals, a_csr_cmplx%indj, a_csr_cmplx%indi, &
                     tmp_csr_cmplx%vals, tmp_csr_cmplx%indj, tmp_csr_cmplx%indi, tmp_csr_cmplx%nz, info_mkl)
! copy result back to a_csr_cmplx
          a_csr_cmplx = tmp_csr_cmplx
    endif

endif

end subroutine mul_diacsr_cmplx
!==========================================================================================

!==========================================================================================
subroutine add_csr_cmplx(a_csr_cmplx, beta, b_csr_cmplx, method, c_csr_cmplx)
! C := A + beta*B
implicit none

     type (csr_cmplx)           :: a_csr_cmplx, b_csr_cmplx, tmp_csr_cmplx
     type (csr_cmplx), optional :: c_csr_cmplx
     complex(cwp)               :: beta
     character :: method

     integer   :: request, sort, info_mkl, istat
     character :: trans
     integer, allocatable :: iw(:)

if (method == skit) then

!sparskit
    if (present(c_csr_cmplx)) then
! requires careful pre-allocation, tedious, not done properly
!     call aplsca_cmplx (mat_csr_cmplx%ni, mat_csr_cmplx%nz, mat_csr_cmplx%vals, mat_csr_cmplx%indj, mat_csr_cmplx%indi, &
!                                      - i*pars%omega0, iw)
    else

    endif
else

!mkl
trans = 'n'
request = 1 !the routine computes only values of the array indi of length ni + 1,
            !the memory for this array must be allocated beforehand. On exit the value indi(ni+1) - 1 is nz
sort = 0

!print "allocated?", allocated(tmp_csr_cmplx%indi), allocated(tmp_csr_cmplx%indj), allocated(tmp_csr_cmplx%vals)


allocate(iw(a_csr_cmplx%ni + 1),stat=istat)
iw = 0

     call mkl_zcsradd(trans, request, sort, a_csr_cmplx%ni, a_csr_cmplx%nj, &
                  a_csr_cmplx%vals, a_csr_cmplx%indj, a_csr_cmplx%indi, &
                  beta, b_csr_cmplx%vals, b_csr_cmplx%indj, b_csr_cmplx%indi, &
                  tmp_csr_cmplx%vals, tmp_csr_cmplx%indj, iw, tmp_csr_cmplx%nz, info_mkl)

     call init_sparse_0( tmp_csr_cmplx, a_csr_cmplx%ni, a_csr_cmplx%nj, iw(a_csr_cmplx%ni+1)-1 )
     tmp_csr_cmplx%indi = iw

deallocate(iw)

request = 2 !been called previously with the parameter request=1, the output arrays are allocated

     call mkl_zcsradd(trans, request, sort, a_csr_cmplx%ni, a_csr_cmplx%nj, &
                  a_csr_cmplx%vals, a_csr_cmplx%indj, a_csr_cmplx%indi, &
                  beta, b_csr_cmplx%vals, b_csr_cmplx%indj, b_csr_cmplx%indi, &
                  tmp_csr_cmplx%vals, tmp_csr_cmplx%indj, tmp_csr_cmplx%indi, tmp_csr_cmplx%nz, info_mkl)
print *, "c"
    if (present(c_csr_cmplx)) then
          call init_sparse_0(c_csr_cmplx, tmp_csr_cmplx%ni, tmp_csr_cmplx%nj, tmp_csr_cmplx%nz)
! copy result to c_csr_cmplx
          c_csr_cmplx = tmp_csr_cmplx
    else
          call dealloc_sparse(a_csr_cmplx)
          call init_sparse_0(a_csr_cmplx, tmp_csr_cmplx%ni, tmp_csr_cmplx%nj, tmp_csr_cmplx%nz)
! copy result back to a_csr_cmplx
          a_csr_cmplx = tmp_csr_cmplx
    endif

endif

end subroutine add_csr_cmplx
!==========================================================================================

!==========================================================================================
subroutine mul_coo_vec_cmplx(a_coo, b_cmplx, method, c_cmplx)
! C := A*b
!or
! b := A*b
implicit none

     type (triplet)                       :: a_coo
     complex(cwp)                         :: b_cmplx(:)
     complex(cwp), allocatable            :: tmp_cmplx(:)
     complex(cwp), optional               :: c_cmplx(:)
     character :: method

     integer   :: istatus
     character        :: transa
     character(len=6) :: matdescra! = 'GOOF'
     complex(cwp):: alpha, beta


if (method == skit) then

!sparskit
    if (present(c_cmplx)) then
         call triplet_vector_mult_cmplx(a_coo, b_cmplx, c_cmplx)
    else
         allocate(tmp_cmplx(a_coo%ni), stat = istatus)
         call triplet_vector_mult_cmplx(a_coo, b_cmplx, tmp_cmplx)
          ! copy result back to b_cmplx
         b_cmplx = tmp_cmplx
    endif
else

!mkl
transa = 'n'
alpha = 1.
beta = 0.
 matdescra(1:1) = 'G'
 matdescra(4:4) = 'F'

    if (present(c_cmplx)) then
                          !print *, dot_product(c_cmplx, c_cmplx),dot_product(b_cmplx, b_cmplx)
          call mkl_zcoomv(transa, a_coo%ni, a_coo%nj, alpha, matdescra, &
                          cmplx(a_coo%vals, 0, cwp), a_coo%indi, a_coo%indj, a_coo%nz, b_cmplx, beta, c_cmplx)
    else
          allocate(tmp_cmplx(a_coo%ni),  stat = istatus)
          call mkl_zcoomv(transa, a_coo%ni, a_coo%nj, alpha, matdescra, &
                          cmplx(a_coo%vals, 0, cwp), a_coo%indi, a_coo%indj, a_coo%nz, b_cmplx, beta, tmp_cmplx)
          ! copy result back to b_cmplx
          b_cmplx = tmp_cmplx
    endif

endif

end subroutine mul_coo_vec_cmplx
!==========================================================================================
!==========================================================================================
subroutine add_diacsr_cmplx(a_csr_cmplx, diag, b_csr_cmplx)
! NO MEMORY ALLOCATION, diagonal elements in A are nonzeros
! B = A + Diag
!or
! A = A + Diag
implicit none

     type (csr_cmplx)              :: a_csr_cmplx
     type (csr_cmplx), optional    :: b_csr_cmplx
     complex(cwp)                  :: diag(:)
!     character :: method

!     integer :: request, sort, info_mkl, j
!     character  trans
!     integer, allocatable :: ones(:)

     integer :: iw(a_csr_cmplx%ni)


!if (method == skit) then

!sparskit
    if (present(b_csr_cmplx)) then
        call init_sparse_0(b_csr_cmplx, a_csr_cmplx%ni, a_csr_cmplx%nj, a_csr_cmplx%nz)
        print *, "2"
        call apldia_cmplx(a_csr_cmplx%ni, 1, a_csr_cmplx%vals, a_csr_cmplx%indj, a_csr_cmplx%indi, &
                          diag, b_csr_cmplx%vals, b_csr_cmplx%indj, b_csr_cmplx%indi, iw)
    else
    print *, "1"
        call apldia_cmplx(a_csr_cmplx%ni, 0, a_csr_cmplx%vals, a_csr_cmplx%indj, a_csr_cmplx%indi, &
                          diag, a_csr_cmplx%vals, a_csr_cmplx%indj, a_csr_cmplx%indi, iw)
    endif
!else
!
!mkl
!
!endif

end subroutine add_diacsr_cmplx
!==========================================================================================

!==========================================================================================

end module my_sparse_aggregate
